using UnityEngine;
using UnityEngine.Rendering;
using System.Collections.Generic;

#pragma warning disable 162

using ImprovedPerlinNoiseProject;
using MarchingCubesGPUProject;

public class CaveGenGPU : MonoBehaviour
{
    //The size of the voxel array for each dimension
    public const int chunk_width = 64;
    public const int chunk_height = 64;
    public const int chunk_length = 64;
    public const int chunk_plus_width = chunk_width + 16;
    public const int chunk_plus_height = chunk_height + 16;
    public const int chunk_plus_length = chunk_length + 16;

    //The size of the buffer that holds the verts.
    //This is the maximum number of verts that the 
    //marching cube can produce, 5 triangles for each voxel.
    const int SIZE = (chunk_plus_width+2) * (chunk_plus_height+2) * (chunk_plus_length+2) * 3 * 5;

    public GameObject tracking;

    public int m_seed = 0;

    public Material m_drawBuffer;

    public ComputeShader m_perlinNoise;

    public ComputeShader m_marchingCubes;

    public ComputeShader m_normals;

    ComputeBuffer m_noiseBuffer, m_meshBuffer;

    RenderTexture m_normalsBuffer;

    ComputeBuffer m_cubeEdgeFlags, m_triangleConnectionTable;

    GPUPerlinNoise perlin;

    public Material terrain_material;

    public bool generate = false; // Let the user generate once they put in the right shaders

    Dictionary<Vector3Int, List<GameObject>> generated_chunks;


    public Vector3 GetTrackingChunk()
    {
        Vector3 pos_tracking = tracking.transform.position;
        var pos = GetComponent<Transform>().position;
        var scale = GetComponent<Transform>().localScale;
        //new Vector3(pos.x - chunk_width * scale.x / 2f, pos.y - chunk_height * scale.y / 2f, pos.z - chunk_length * scale.z / 2f);
        pos_tracking.x /= chunk_width * scale.x;
        pos_tracking.y /= chunk_height * scale.y;
        pos_tracking.z /= chunk_height * scale.z;

        Debug.Log($"Tracking: x:{pos_tracking.x}, y:{pos_tracking.y}, z:{pos_tracking.z}");

        return pos_tracking;
    }

    public void OnDrawGizmos()
    {
        if (generate)
        {
            DeleteGenerated();
            Init();
            Vector3 chunk = GetTrackingChunk();
            Vector3Int chunk_int = new Vector3Int(Mathf.RoundToInt(chunk.x), Mathf.RoundToInt(chunk.y), Mathf.RoundToInt(chunk.z));
            MakeChunk(chunk_int);
            generate = false;
        }
    }

    public void DeleteGenerated()
    {
        while (transform.childCount > 0)
        {
            foreach (Transform child in transform)
            {
                DestroyImmediate(child.gameObject);
            }
        }

    }

    private void Init()
    {
        generated_chunks = new Dictionary<Vector3Int, List<GameObject>>();
        //Allows this camera to draw mesh procedurally.
        PostRenderEvent.AddEvent(Camera.main, DrawMesh);

        //There are 8 threads run per group so N must be divisible by 8.
        if (chunk_width % 8 != 0 || chunk_height % 8 != 0 || chunk_length % 8 != 0)
            throw new System.ArgumentException("Dimensions must be divisible be 8");

        //Holds the voxel values, generated from perlin noise.
        m_noiseBuffer = new ComputeBuffer(chunk_plus_width * chunk_plus_height * chunk_plus_length, sizeof(float));

        //Holds the normals of the voxels.
        m_normalsBuffer = new RenderTexture(chunk_plus_width, chunk_plus_height, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
        m_normalsBuffer.dimension = TextureDimension.Tex3D;
        m_normalsBuffer.enableRandomWrite = true;
        m_normalsBuffer.useMipMap = false;
        m_normalsBuffer.volumeDepth = chunk_plus_length;
        m_normalsBuffer.Create();

        //Holds the verts generated by the marching cubes.
        m_meshBuffer = new ComputeBuffer(SIZE, sizeof(float) * 7);

        //These two buffers are just some settings needed by the marching cubes.
        m_cubeEdgeFlags = new ComputeBuffer(256, sizeof(int));
        m_cubeEdgeFlags.SetData(MarchingCubesTables.CubeEdgeFlags);
        m_triangleConnectionTable = new ComputeBuffer(256 * 16, sizeof(int));
        m_triangleConnectionTable.SetData(MarchingCubesTables.TriangleConnectionTable);

        //Make the perlin noise, make sure to load resources to match shader used.
        perlin = new GPUPerlinNoise(m_seed);
        perlin.LoadResourcesFor3DNoise();
    }

    private void MakeChunk(Vector3Int location)
    {
        //Clear the mesh verts to -1. See the TriangleConnectionTable.
        //Only verts that get generated will then have a value of 1.
        //Only required if reading back the mesh.
        //Could also use the ClearMesh compute shader provided.
        float[] val = new float[SIZE * 7];
        for (int i = 0; i < SIZE * 7; i++)
            val[i] = -1.0f;

        m_meshBuffer.SetData(val);

        //Make the voxels.
        m_perlinNoise.SetInt("_Width", chunk_plus_width);
        m_perlinNoise.SetInt("_Height", chunk_plus_height);
        m_perlinNoise.SetInt("_OffsetX", location.x* chunk_width);
        m_perlinNoise.SetInt("_OffsetY", location.y* chunk_height);
        m_perlinNoise.SetInt("_OffsetZ", location.z* chunk_length);
        m_perlinNoise.SetInt("_FullOffsetX", location.x * chunk_plus_width);
        m_perlinNoise.SetInt("_FullOffsetY", location.y * chunk_plus_height);
        m_perlinNoise.SetInt("_FullOffsetZ", location.z * chunk_plus_length);
        m_perlinNoise.SetFloat("_Frequency", 0.02f);
        m_perlinNoise.SetFloat("_Lacunarity", 2.0f);
        m_perlinNoise.SetFloat("_height_dieoff", .04f);
        
        m_perlinNoise.SetFloat("_Gain", 0.5f);
        m_perlinNoise.SetTexture(0, "_PermTable2D", perlin.PermutationTable2D);
        m_perlinNoise.SetTexture(0, "_Gradient3D", perlin.Gradient3D);
        m_perlinNoise.SetBuffer(0, "_Result", m_noiseBuffer);

        m_perlinNoise.Dispatch(0, chunk_plus_width / 8, chunk_plus_height / 8, chunk_plus_length / 8);

        //todo: make normals and marching cubes take subsection of voxels, so they have edge data

        //Make the voxel normals.
        m_normals.SetInt("_Width", chunk_plus_width);
        m_normals.SetInt("_Height", chunk_plus_height);
        m_normals.SetBuffer(0, "_Noise", m_noiseBuffer);
        m_normals.SetTexture(0, "_Result", m_normalsBuffer);

        m_normals.Dispatch(0, chunk_plus_width / 8, chunk_plus_height / 8, chunk_plus_length / 8);

        //Make the mesh verts
        m_marchingCubes.SetInt("_Width", chunk_width);
        m_marchingCubes.SetInt("_Height", chunk_height);
        m_marchingCubes.SetInt("_Depth", chunk_length);
        m_marchingCubes.SetInt("_Width_Plus", chunk_plus_width);
        m_marchingCubes.SetInt("_Height_Plus", chunk_plus_height);
        m_marchingCubes.SetInt("_Depth_Plus", chunk_plus_length);
        m_marchingCubes.SetInt("_Border", -2);
        m_marchingCubes.SetFloat("_Target", 0.0f);
        m_marchingCubes.SetBuffer(0, "_Voxels", m_noiseBuffer);
        m_marchingCubes.SetTexture(0, "_Normals", m_normalsBuffer);
        m_marchingCubes.SetBuffer(0, "_Buffer", m_meshBuffer);
        m_marchingCubes.SetBuffer(0, "_CubeEdgeFlags", m_cubeEdgeFlags);
        m_marchingCubes.SetBuffer(0, "_TriangleConnectionTable", m_triangleConnectionTable);

        m_marchingCubes.Dispatch(0, chunk_plus_width / 8, chunk_plus_height / 8, chunk_plus_length / 8);

        //Reads back the mesh data from the GPU and turns it into a standard unity mesh.
        generated_chunks[location] = ReadBackMesh(m_meshBuffer, location);
    }

    void Start()
    {
        //MakeChunk();
        DeleteGenerated();
        Init();

    }

    void Update()
    {
        Vector3 chunk = GetTrackingChunk();
        Vector3Int chunk_int = new Vector3Int(Mathf.RoundToInt(chunk.x), Mathf.RoundToInt(chunk.y), Mathf.RoundToInt(chunk.z));

        for (int i=-1; i<=1; i++)
        {
            for (int j = -1; j <= 1; j++)
            {
                for (int k = -1; k <= 1; k++)
                {
                    Vector3Int new_chunk_int = chunk_int + new Vector3Int(i, j, k);
                    if (!generated_chunks.ContainsKey(new_chunk_int)){
                        MakeChunk(new_chunk_int);
                    }
                }
            }
        }
    }


    /// <summary>
    /// Draws the mesh when cameras OnPostRender called.
    /// </summary>
    /// <param name="camera"></param>
    void DrawMesh(Camera camera)
    {
        //Since mesh is in a buffer need to use DrawProcedual called from OnPostRender
        m_drawBuffer.SetBuffer("_Buffer", m_meshBuffer);
        m_drawBuffer.SetPass(0);

        Graphics.DrawProceduralNow(MeshTopology.Triangles, SIZE);
    }

    void OnDestroy()
    {
        //MUST release buffers.
        m_noiseBuffer.Release();
        m_meshBuffer.Release();
        m_cubeEdgeFlags.Release();
        m_triangleConnectionTable.Release();
        m_normalsBuffer.Release();

        PostRenderEvent.RemoveEvent(Camera.main, DrawMesh);
    }

    struct Vert
    {
        public Vector4 position;
        public Vector3 normal;
    };

    /// <summary>
    /// Reads back the mesh data from the GPU and turns it into a standard unity mesh.
    /// </summary>
    /// <returns></returns>
    List<GameObject> ReadBackMesh(ComputeBuffer meshBuffer, Vector3Int chunk_offset)
    {
        //Get the data out of the buffer.
        Vert[] verts = new Vert[SIZE];
        meshBuffer.GetData(verts);

        //Extract the positions, normals and indexes.
        List<Vector3> positions = new List<Vector3>();
        List<Vector3> normals = new List<Vector3>();
        List<int> index = new List<int>();

        List<GameObject> objects = new List<GameObject>();

        int idx = 0;
        for (int i = 0; i < SIZE; i++)
        {
            //If the marching cubes generated a vert for this index
            //then the position w value will be 1, not -1.
            if (verts[i].position.w != -1)
            {
                positions.Add(verts[i].position);
                normals.Add(verts[i].normal);
                index.Add(idx++);
            }

            int maxTriangles = 65000 / 3;

            if (idx >= maxTriangles)
            {
                objects.Add(MakeGameObject(positions, normals, index, chunk_offset));
                idx = 0;
                positions.Clear();
                normals.Clear();
                index.Clear();
            }
        }

        return objects;
    }

    GameObject MakeGameObject(List<Vector3> positions, List<Vector3> normals, List<int> index, Vector3Int chunk_offset)
    {
        Mesh mesh = new Mesh();
        mesh.vertices = positions.ToArray();
        mesh.normals = normals.ToArray();
        mesh.bounds = new Bounds(new Vector3(0, chunk_width / 2, 0), new Vector3(chunk_width, chunk_height, chunk_length));
        mesh.SetTriangles(index.ToArray(), 0);

        GameObject go = new GameObject("Voxel Mesh");
        go.transform.parent = transform;
        go.AddComponent<MeshFilter>();
        go.AddComponent<MeshCollider>();
        go.AddComponent<MeshRenderer>();
        go.GetComponent<Renderer>().material = terrain_material;
        go.GetComponent<MeshFilter>().mesh = mesh;
        go.GetComponent<MeshFilter>().mesh = mesh;
        go.GetComponent<MeshCollider>().sharedMesh = mesh;
        go.GetComponent<MeshCollider>().convex = false;
        var pos = GetComponent<Transform>().position;
        var scale = GetComponent<Transform>().localScale;
        //Center
        go.transform.localPosition = new Vector3(0, -(chunk_height * scale.y) / 2f, 0);
        //go.transform.localPosition = new Vector3(pos.x - chunk_width * scale.x / 2f, pos.y - chunk_height * scale.y / 2f, pos.z - chunk_length * scale.z / 2f);
        go.transform.localPosition += (new Vector3(chunk_offset.x * chunk_width * scale.x, chunk_offset.y * chunk_height * scale.y, chunk_offset.z * chunk_length * scale.z)*(2f));
        //go.transform.localScale = scale + new Vector3(2f/chunk_width, 2f / chunk_height, 2f / chunk_length);
        //go.isStatic = true;
        

        return go;
    }
}




























